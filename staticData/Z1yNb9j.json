{"post":{"id":48,"path":"/2018/10/08/clean-architecture/","date":"2018/10/08 17:20","title":"Clean Architecture を読んだ","description":"2018年8月に発売されたClean Architecture 達人に学ぶソフトウェアの構造と設計を読んだのでその感想とメモです。","tags":["reading","architecture"],"body":"<p>8月に和訳版が発売されて、Twitterのタイムラインを見てるとなかなか評判が良さそうだったので読んでみた。思えばアーキテクチャについての本は読んだことがなかったので、とても参考になった。<br>\n設計に関する原則は色々と紹介されていたが、正直、読了直後でもどれが何のことを表していたか...ってごっちゃになってしまっていたので、思い出したいときのために整理しておく。</p>\n<div class=\"cstmreba\"><div class=\"kaerebalink-box\"><div class=\"kaerebalink-image\"><a href=\"https://www.amazon.co.jp/exec/obidos/ASIN/B07FSBHS2V/bakunyo-22/\" target=\"_blank\" ><img src=\"https://images-fe.ssl-images-amazon.com/images/I/51mQrYTahJL._SL160_.jpg\" style=\"border: none;\" /></a></div><div class=\"kaerebalink-info\"><div class=\"kaerebalink-name\"><a href=\"https://www.amazon.co.jp/exec/obidos/ASIN/B07FSBHS2V/bakunyo-22/\" target=\"_blank\" >Clean Architecture　達人に学ぶソフトウェアの構造と設計 (アスキードワンゴ)</a><div class=\"kaerebalink-powered-date\">posted with <a href=\"https://kaereba.com\" rel=\"nofollow\" target=\"_blank\">カエレバ</a></div></div><div class=\"kaerebalink-detail\">Ｒｏｂｅｒｔ Ｃ．Ｍａｒｔｉｎ,角 征典,高木 正弘 ドワンゴ 2018-08-01    </div><div class=\"kaerebalink-link1\"></div></div><div class=\"booklink-footer\"></div></div></div>\n<h2>SOLID原則</h2>\n<p>関数やデータ構造をどのようにクラスに組み込むのか、そしてクラスの相互接続をどのようにするのかについての原則</p>\n<h5>単一責任の原則（SRP: Single Responsibility Principle）</h5>\n<ul>\n<li>モジュールを変更する理由がたったひとつ（\bのアクター）になるようにする</li>\n<li>「\b各モジュールはたったひとつのことだけを行うべき」と誤解されがち</li>\n<li>似たような処理でもアクターの異なるコードは分割するべき</li>\n</ul>\n<h5>オープン・クローズドの原則（OCP: Open-Closed Principle）</h5>\n<ul>\n<li>拡張に対して開いて、修正に対して閉じていなければならない</li>\n<li>1988年、 Bertland Meyer が提唱</li>\n<li>ソフトウェアを変更しやすくするために、既存のコード変更より新しいコードの追加で振る舞いを変更できるようにする</li>\n</ul>\n<h5>リスコフの置換原則（LSP: Liskov Substitution Principle）</h5>\n<ul>\n<li>交換可能なパーツを使ってソフトウェア・システムを構築するなら、個々のパーツが交換可能となるような契約に従わなければならない</li>\n<li>1988年、 Barbara Liskov が提唱した有名な派生型の定義。</li>\n<li>この原則違反の有名な例が「正方形・長方形」問題</li>\n</ul>\n<h5>インターフェイス分離の原則（ISP: Interface Segregation Principle）</h5>\n<ul>\n<li>使っていないものへの依存を回避すべき</li>\n</ul>\n<h5>依存関係逆転の原則（DIP: Dependency Inversion Principle）</h5>\n<ul>\n<li>上位レベルの方針の実装コードは、下位レベルの詳細の実装コードに依存すべきではなく、逆に詳細側が方針に依存すべき</li>\n<li>ソースコードの依存関係が（具象ではなく）抽象だけを参照しているのが最も柔軟なシステム</li>\n</ul>\n<h2>コンポーネントの原則</h2>\n<p>コンポーネント = デプロイの単位</p>\n<h3>凝集性に関する原則</h3>\n<h5>再利用・リリース等価の原則（REP: Reuse-Release Equivalency Principle）</h5>\n<ul>\n<li>再利用の単位とリリースの単位は等価になる</li>\n<li>リリース番号がついてなければ、再利用するコンポーネントの互換性を確認できないので、当然の原則のようにも思える</li>\n</ul>\n<h5>閉鎖性共通の原則（CCP: Common Closure Principle）</h5>\n<ul>\n<li>同じ理由、同じタイミングで変更されるクラスをコンポーネントにまとめる。どちらかが異なる場合は別のコンポーネントに分けること</li>\n<li>\bSRPをコンポーネント向けに言い換えたもの</li>\n</ul>\n<h5>全再利用の原則（CRP: Common Reuse Principle）</h5>\n<ul>\n<li>コンポーネントのユーザーに対して、実際には使わないものの依存を強要しては\bいけない</li>\n<li>ISPをコンポーネント向けに言い換えたもの</li>\n</ul>\n<br />\n3つの原則は相関し、相反するものもある。開発時の利便性と再利用性・プロジェクトの進捗度によってコンポーネントの構成も変わっていく\n<h3>結合に関する原則</h3>\n<p>コンポーネントの関連を扱う3つの原則</p>\n<h5>非循環依存関係の原則（ADP: Acyclic Dependencies Principle）</h5>\n<ul>\n<li>コンポーネントの依存グラフに循環依存があってはいけない</li>\n<li>循環依存があると、依存関係の混乱、ビルド（リリース）の順番を決めるのが難しくなる</li>\n<li>循環依存を解消するために、依存関係逆転の原則（DIP）を適用する</li>\n</ul>\n<h5>安定依存の原則（SDP: Stable Dependencies Principle）</h5>\n<ul>\n<li>安定度の高い方向に依存すること</li>\n<li>依存されているコンポーネントが多い程変更しにくいので、安定度が高いと考える</li>\n<li>指標の例： 不安定度 = 依存しているコンポーネントの数 / (依存しているコンポーネントの数 + 依存されているコンポーネントの数)</li>\n</ul>\n<h5>安定度・抽象度等価の原則（SAP: Stable Abstractions Principle）</h5>\n<ul>\n<li>コンポーネントの抽象度は、その安定度と同程度でなければならない</li>\n<li>\bSDPと組み合わせると、抽象度の高い方向に依存すべきということ</li>\n<li>違反してしまってるのがDBスキーマ。変更されやすく、抽象度は低く、他から依存されまくっている</li>\n<li>Stability-Abstraction Equivalency Principle とかじゃねーのかよって思った（どうでもいい）</li>\n</ul>\n<h2>その他のメモ</h2>\n<ul>\n<li>ソフトウェアアーキテクチャの目的は、求められるシステムを構築・保守するために必要な人材を最小限に抑えること</li>\n<li>ソフトウェアの1つ目の価値（振る舞い）は緊急だが、常に重要とは限らない</li>\n<li>ソフトウェアの2つ目の価値（アーキテクチャ）は重要だが、常に緊急とは限らない</li>\n<li>プログラミングパラダイムとアーキテクチャ\n<ul>\n<li>構造化プログラミングは、直接的な制御の移行に規律を課す\n<ul>\n<li>アーキテクチャレベルでは機能分割に役立つ</li>\n</ul>\n</li>\n<li>オブジェクト指向プログラミングは、間接的な制御の移行に規律を課す\n<ul>\n<li>ポリモーフィズムを使用することでソースコードの依存関係を絶対的に制御する能力</li>\n</ul>\n</li>\n<li>関数型プログラミングは、代入に規律を課す\n<ul>\n<li>イベントソーシング（状態ではなく取引を保存する）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>ソフトウェアをソフトに保つには、なるべく多く選択肢を残すこと。その選択肢とは、重要でない「詳細」のこと\n<ul>\n<li>「方針」と「詳細」</li>\n<li>方針とは、ビジネスルールや手順、システムの本当の価値</li>\n<li>詳細とは、方針についてやりとりするものだが方針の振る舞いに影響を与えないもの。IOデバイス、DB、Web、Server、Framework、通信プロトコルなど</li>\n</ul>\n</li>\n<li>レベルについて\n<ul>\n<li>「入力と出力からの距離」を「レベル」と定義する</li>\n<li>ソースコードの依存性をデータフローから切り離し、レベルと結びつけるべき</li>\n</ul>\n</li>\n<li>アーキテクチャの境界を予測的に設計する（YAGNI否定）</li>\n</ul>\n<h2>感想</h2>\n<p>第Ⅳ部「詳細」では普段接している様々な技術（データベース・Web・フレームワーク等）を重要ではない「詳細」だと言い切っている。<br>\n（訳者あとがきにも似たようなことが書いてあるけど）自分もアプリをつくる時に言語は？FWは？どこで動かす？などをすぐに考えてしまうし、アーキテクチャもその都度都度で最適だと思うようにつくっていけばいいでしょと考えてしまっていたのは反省すべきポイントだった。<br>\n小さなクラス設計からデプロイ単位のコンポーネント設計まで、ちゃんと意識できてるって思えるまでは実践を積み重ねるしかないと思うのでこれから頑張っていこうと思う。</p>\n"}}