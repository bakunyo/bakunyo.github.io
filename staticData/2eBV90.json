{"post":{"id":50,"path":"/2019/07/12/gomock-tutorial/","date":"2019/07/12 15:13","title":"go でモックを使うテストを書く","description":"gomock の基本的な使い方についてのメモ.","tags":["golang","test"],"body":"<p><a href=\"https://golang.org/\">Go</a>でモックを使うテストを書く時に利用する<a href=\"https://github.com/golang/mock\">gomock</a>について簡単に整理しておく</p>\n<h2>使い方</h2>\n<p>大まかに3ステップ</p>\n<ol>\n<li>Install</li>\n<li>Generate</li>\n<li>Test</li>\n</ol>\n<h2>Install</h2>\n<p>テストの際に使うパッケージとGenerateコマンドのためのパッケージをそれぞれインストール</p>\n<pre><code class=\"hljs bash\">go get github.com/golang/mock/gomock\ngo install github.com/golang/mock/mockgen\n</code></pre>\n<h2>Generate</h2>\n<p><code>source mode</code> と <code>reflect mode</code> の2種類の使い方がある</p>\n<h3>source mode</h3>\n<p>ソースファイルを指定</p>\n<pre><code class=\"hljs \">mockgen -source={filepath} [options]\n</code></pre>\n<p><code>-destination</code> を指定しないと標準出力に出力される</p>\n<h3>reflect mode</h3>\n<p>Import pathと対象のシンボルを指定</p>\n<pre><code class=\"hljs \">mockgen {import path} {symbol[,...]}\n</code></pre>\n<ul>\n<li>複数のシンボルを指定する際はカンマ区切り指定</li>\n<li><code>reflect mode</code> は reflection によって interface を理解するプログラムをビルドして mock を生成するらしいが、イマイチ違いは理解できてない(単純なケースなら <code>source mode</code> で十分とある)</li>\n</ul>\n<h2>Test</h2>\n<p>READMEには Mocks と Stubs の2通りの使い方がある<br>\nとはいえ、使い方はほぼ同じなのでここではMockの方だけメモを残しておく</p>\n<p>テストの中で登場する <code>Controller</code> は、 <code>Mock</code> で起きたことを監視する役割を持つと思っておけば良い</p>\n<pre><code class=\"hljs golang\"><span class=\"hljs-keyword\">type</span> Foo <span class=\"hljs-keyword\">interface</span> {\n  Bar(x <span class=\"hljs-keyword\">int</span>) <span class=\"hljs-keyword\">int</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">SUT</span><span class=\"hljs-params\">(f Foo)</span></span> {\n <span class=\"hljs-comment\">// ...</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">TestFoo</span><span class=\"hljs-params\">(t *testing.T)</span></span> {\n  ctrl := gomock.NewController(t)\n\n  <span class=\"hljs-comment\">// Assert that Bar() is invoked.</span>\n  <span class=\"hljs-keyword\">defer</span> ctrl.Finish()\n\n  m := NewMockFoo(ctrl)\n\n  <span class=\"hljs-comment\">// Asserts that the first and only call to Bar() is passed 99.</span>\n  <span class=\"hljs-comment\">// Anything else will fail.</span>\n  m.\n    EXPECT().\n    Bar(gomock.Eq(<span class=\"hljs-number\">99</span>)).\n    Return(<span class=\"hljs-number\">101</span>)\n\n  SUT(m)\n}\n</code></pre>\n<p>上からざっくり解説</p>\n<ol>\n<li>mockに渡すための Controller を生成する</li>\n<li>最後に Controller の <code>Finish()</code> を呼ぶことで、Mock に期待したメソッド呼び出しのチェックをする(ここではBar)</li>\n<li>Mockに対して <code>EXPECT()</code> の後に、呼ばれることが期待される関数と引数を指定する</li>\n<li>Mockに返して欲しい返り値を指定する</li>\n</ol>\n<h4>その他メモ</h4>\n<ul>\n<li>\n<p>Mockが用意した <code>EXPECT()</code> メソッドが全て大文字なのは、 interface に定義されるかもしれない <code>Expect()</code> などとの名前衝突を避けるため</p>\n</li>\n<li>\n<p>上記の例ではMockに対して <code>Bar</code> が引数1つ(<code>99</code>)で呼び出されることを期待している</p>\n</li>\n<li>\n<p>引数のMatcherはいくつか種類があるが、例えば <code>Bar(99)</code> とそのまま値を渡してもgomock 側でよしなに <code>Bar(gomock.Eq(99)</code> と解釈してくれる</p>\n</li>\n<li>\n<p>Matcher は自作できる</p>\n</li>\n</ul>\n<h4>順序について</h4>\n<p><code>EXPECT()</code> を複数書いた場合、何もしなければ呼び出し順序までは期待できない。<br>\n順序を指定したい場合は <code>After</code> か <code>InOrder</code> を使う</p>\n<pre><code class=\"hljs \"># Bar1 -&gt; Bar2の順に呼び出されることを期待する\ngomock.InOrder(\n  m.EXPECT().Bar1(99),\n  m.EXPECT().Bar2(100),\n)\n</code></pre>\n<h2>Reference</h2>\n<p><a href=\"https://blog.codecentric.de/en/2017/08/gomock-tutorial/\">https://blog.codecentric.de/en/2017/08/gomock-tutorial/</a></p>\n"}}